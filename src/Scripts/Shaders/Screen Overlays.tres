[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;

uniform bool effectActive = false;
uniform int effectType = 0;

uniform vec2 center = vec2(0.5, 0.5);
uniform sampler2D noise;
uniform float sample_radius: hint_range(0.0, 1.0) = 0.5;
uniform vec4 line_color: hint_color = vec4(1.0);
uniform float center_radius: hint_range(0.0, 1.0) = 0.5;

const float pi = 3.14159265359;

uniform float aberWidth = 5.;

void fragment() {
	vec4 background = texture(SCREEN_TEXTURE, SCREEN_UV);
	
	float msin = sin(TIME*2.) * 0.25 + 0.5;
	
	vec4 color;
	// Case-dependent output
	switch(effectType) {
		case 0:
			color = background;
			break;
		case 1:
			//Grayscale shader
			float value = 0.299*background.r + 0.587 * background.g + 0.114 * background.b;
			color = vec4(vec3(value), 1.);
			break;
		case 2:
			//Chromatic aberration shader
			float offsetter = aberWidth * msin + 0.5;
			vec4 aber_left = texture(SCREEN_TEXTURE, vec2(SCREEN_UV.x + SCREEN_PIXEL_SIZE.x *offsetter, SCREEN_UV.y));
			vec4 aber_right = texture(SCREEN_TEXTURE, vec2(SCREEN_UV.x - SCREEN_PIXEL_SIZE.x *offsetter, SCREEN_UV.y));
			
			color = vec4(aber_left.r, aber_right.g * 0.95, background.b, 1.);
			break;
		case 3:
			//Speedlines shader
			vec2 dist = UV - center;
			float angle = atan(dist.y / dist.x);
			vec2 sample = vec2(sample_radius * cos(angle), sample_radius * sin(angle));
			float noise_value = texture(noise, sample).r;
			vec4 figcolor = mix(line_color, vec4(0.0), noise_value);
			color = mix(figcolor, vec4(0.0), 1.0 - length(dist) - center_radius);
			break;
		default:
			//Default shader
			color = background;
			break;
	}
	
	COLOR = color;
	
}"
